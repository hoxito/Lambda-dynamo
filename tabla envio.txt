// CODIGO TABLA ENVIO

var params = {
    TableName: 'Envio',
    KeySchema: [ // The type of of schema.  Must start with a HASH type, with an optional second RANGE.
        { // Required HASH type attribute
            AttributeName: 'id',
            KeyType: 'HASH',
        },
    ],
    AttributeDefinitions: [ // The names and types of all primary and index key attributes only
        {
            AttributeName: 'id',
            AttributeType: 'S', // (S | N | B) for string, number, binary
        },{
        AttributeName: 'pendiente',
            AttributeType: 'S', // (S | N | B) for string, number, binary
        }
    
        // ... more attributes ...
    ],
    ProvisionedThroughput: { // required provisioned throughput for the table
        ReadCapacityUnits: 1, 
        WriteCapacityUnits: 1, 
    },
    GlobalSecondaryIndexes: [ // optional (list of GlobalSecondaryIndex)
        { 
            IndexName: 'EnviosPendientesIndex', 
            KeySchema: [
                { // Required HASH type attribute
                    AttributeName: 'id',
                    KeyType: 'HASH',
                },
                { // Optional RANGE key type for HASH + RANGE secondary indexes
                    AttributeName: 'pendiente', 
                    KeyType: 'RANGE', 
                }
            ],
            Projection: { // attributes to project into the index
                ProjectionType: 'INCLUDE', // (ALL | KEYS_ONLY | INCLUDE)
                NonKeyAttributes: [ // required / allowed only for INCLUDE
                    'pendiente',
                    // ... more attribute names ...
                ],
            },
            ProvisionedThroughput: { // throughput to provision to the index
                ReadCapacityUnits: 1,
                WriteCapacityUnits: 1,
            },
        },
        // ... more global secondary indexes ...
    ],
};
dynamodb.createTable(params, function(err, data) {
    if (err) ppJson(err); // an error occurred
    else ppJson(data); // successful response

});

//////////


    var dynamodb = new AWS.DynamoDB({
        apiVersion: '2012-08-10',
        endpoint: 'http://dynamodb:8000',
        region: 'us-west-2',
        credentials: {
            accessKeyId: '2345',
            secretAccessKey: '2345'
        }
    });

    var docClient = new AWS.DynamoDB.DocumentClient({
        apiVersion: '2012-08-10',
        service: dynamodb
    });

let re = new RegExp('^/envios.*')
// codigo de la funcion
console.log("entra1")
if (re.test(event.path)){
    console.log("entra2")
    
switch (httpMethod) {

    case 'GET':
        const idEnvioFind = (pathParameters || {}).idEnvio || false;
        if (idEnvioFind) {
            const findEnvioParams = {
                TableName: 'Envio',
                Key: {
                    id: idEnvioFind,
                }
            };

            const envio = await docClient.get(findEnvioParams).promise()
            return {
                statusCode: 200,
                headers: { "content-type": "application/json" },
                body: JSON.stringify(envio)
            }
        }

        const findParams = {
            TableName: 'Envio',
            IndexName: 'EnviosPendientesIndex'
        };

        try {
            const envios = await docClient.scan(findParams).promise()
            return {
                statusCode: 200,
                headers: { "content-type": "application/json" },
                body: JSON.stringify(envios)
            }
        } catch (err) {
            console.log(err)
            return {
                statusCode: 500,
                headers: { "content-type": "text/plain" },
                body: 'Error get envios'
            };
        }

    case 'POST':
        console.log("entra post")
        const createParams = {
            TableName: 'Envio',
            Item: {
                id: createId(8),
                fechaAlta: new Date().toISOString(),
                ...JSON.parse(body),
                pendiente: new Date().toISOString(),
            }
        }

        try {
            await docClient.put(createParams).promise()
            return {
                statusCode: 200,
                headers: { "content-type": "application/json" },
                body: JSON.stringify(createParams.Item)
            };
        } catch {
            return {
                statusCode: 500,
                headers: { "content-type": "text/plain" },
                body: 'Error creando envio'
            };
        }

    default:
        return {
            statusCode: 501,
            headers: { "content-type": "text/plain" },
            body: `Lo sentimos, el metodo ${httpMethod} no esta soportado`
        };
}
}else{
    return{
        statusCode: 500,
        headers: {"content-type":"text/plain"},
        body:"Lo sentimos, este path es incorrecto"
    }
}